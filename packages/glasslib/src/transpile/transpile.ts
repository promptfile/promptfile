import { checkOk } from '@glass-lang/util'
import fs from 'fs'
import path from 'path'
import { parseChatBlocks } from '../parseChatBlocks'
import { parseFrontmatterFromGlass } from '../parseFrontmatterFromGlass'
import { parseGlassFunctions } from '../parseGlassFunctions'
import { parseGlassMetadata } from '../parseGlassMetadata'
import { transpileToJavascript } from './transpileToJavascript'
import { transpileToPython } from './transpileToPython'
import { transpileToRuby } from './transpileToRuby'
import { transpileToTypescript } from './transpileToTypescript'

export function transpileFile(filePath: string, language: string, defaultModel?: string) {
  const promptfile = fs.readFileSync(filePath, 'utf-8')
  const basename = path.basename(filePath)
  const exportName = normalizeFilename(basename) + 'Prompt'
  const out = transpile(promptfile.toString(), language, { defaultModel, exportName, skipPrefix: true })
  return { out, exportName }
}

export function transpile(
  text: string,
  language: string,
  options: {
    exportName?: string
    defaultModel?: string
    skipPrefix?: boolean
  }
) {
  checkOk(
    language === 'typescript' || language === 'python' || language === 'javascript' || language === 'ruby',
    `Invalid language: ${language}`
  )
  const frontmatter = parseFrontmatterFromGlass(text)
  const model = frontmatter?.model ?? options.defaultModel
  checkOk(model, `No model specified in frontmatter or defaultModel`)

  const blocks = parseChatBlocks(text)
  const variables = parseGlassMetadata(text).interpolationVariables
  const functions = parseGlassFunctions(text)
  let code = ''
  try {
    if (language === 'typescript') {
      code = transpileToTypescript(options.exportName || 'prompt', blocks, variables, functions, model)
      if (!options.skipPrefix) {
        code = transpilePrefix(language) + '\n\n' + code
      }
    } else if (language === 'javascript') {
      code = transpileToJavascript(blocks, variables, functions, model)
    } else if (language === 'python') {
      code = transpileToPython(blocks, variables, functions, model)
    } else if (language === 'ruby') {
      code = transpileToRuby(blocks, variables, functions, model)
    }
    if (code.length === 0) {
      throw new Error(`No code was generated for ${language}`)
    }
    return code
  } catch (error) {
    console.error(error)
    throw error
  }
}

export function transpilePrefix(language: string) {
  if (language !== 'typescript') {
    return ''
  }
  return `/* eslint-disable */
// THIS FILE WAS AUTOGENERATED -- DO NOT EDIT

interface ChatBlock {
  role: 'system' | 'user' | 'assistant' | 'function'
  content: string
  name?: string
  type?: 'function_call'
}

interface LLMFunction {
  name: string
  description?: string
  parameters?: any
}

interface Prompt<T> {
  model: string
  blocks: (args: T) => ChatBlock[]
  functions: LLMFunction[]
}`
}

export function normalizeFilename(fileName: string) {
  if (fileName.endsWith('.prompt')) {
    fileName = fileName.slice(0, -6)
  }

  // strip non-alpha characters
  return fileName.replace(/[^a-zA-Z]/g, '')
}
